fit_lm <- function(dat, ar, m, ARsd, trend, spec = FALSE){
  dat <- dat %>% dplyr::filter(complete.cases(.))
  
  # Constant model (null model used to calculate 
  # overall p-value)
  constant_norm <-nlme::gls(series ~ 1, data = dat)
  
  #spec parameter specifies whether arima.sim incorporated AR(1) error process. When there is no 
  #AR error in the time series, we switch the GLS models to all rely on a normal error generating process.
  if (!spec){
    constant_ar1 <-
      try(nlme::gls(series ~ 1,
                    data = dat,
                    correlation = nlme::corAR1(form = ~time)))
    if (class(constant_ar1) == "try-error"){
      return(best_lm <- data.frame(model = NA,
                                   aicc  = NA,
                                   coefs..Intercept = NA,
                                   coefs.time = NA,
                                   coefs.time2 = NA,
                                   pval = NA))
    }
    
  } else {
    constant_ar1 <-
      try(nlme::gls(series ~ 1,
                    data = dat))
    if (class(constant_ar1) == "try-error"){
      return(best_lm <- data.frame(model = NA,
                                   aicc  = NA,
                                   coefs..Intercept = NA,
                                   coefs.time = NA,
                                   coefs.time2 = NA,
                                   pval = NA))
    }
  }
  # Linear model with normal error
  linear_norm <- nlme::gls(series ~ time, data = dat)
  
  # Linear model with AR1 error
  if (!spec){
    linear_ar1 <- 
      try(nlme::gls(series ~ time, 
                    data = dat,
                    correlation = nlme::corAR1(form = ~time)))
    if (class(linear_ar1) == "try-error"){
      return(best_lm <- data.frame(model = NA,
                                   aicc  = NA,
                                   coefs..Intercept = NA,
                                   coefs.time = NA,
                                   coefs.time2 = NA,
                                   pval = NA))
    }
  } else {
    linear_ar1 <- 
      try(nlme::gls(series ~ time, 
                    data = dat))
    if (class(linear_ar1) == "try-error"){
      return(best_lm <- data.frame(model = NA,
                                   aicc  = NA,
                                   coefs..Intercept = NA,
                                   coefs.time = NA,
                                   coefs.time2 = NA,
                                   pval = NA))
    }
  }
  linear_phi <- linear_ar1$modelStruct$corStruct
  linear_phi <-coef(linear_phi, unconstrained = FALSE)
  
  # Polynomial model with normal error
  dat$time2 <- dat$time^2
  poly_norm <- nlme::gls(series ~ time + time2, data = dat)
  
  # Polynomial model with AR1 error
  if (!spec){
    poly_ar1 <-
      try(nlme::gls(series ~ time + time2,
                    data = dat,
                    correlation = nlme::corAR1(form = ~time)))
    if (class(poly_ar1) == "try-error"){
      return(best_lm <- data.frame(model = NA,
                                   aicc  = NA,
                                   coefs..Intercept = NA,
                                   coefs.time = NA,
                                   coefs.time2 = NA,
                                   pval = NA))
      
    }
  }else {
    poly_ar1 <-
      try(nlme::gls(series ~ time + time2,
                    data = dat))
    if (class(poly_ar1) == "try-error"){
      return(best_lm <- data.frame(model = NA,
                                   aicc  = NA,
                                   coefs..Intercept = NA,
                                   coefs.time = NA,
                                   coefs.time2 = NA,
                                   pval = NA))
      
    }
  }
  poly_phi <- poly_ar1$modelStruct$corStruct
  poly_phi <- coef(poly_phi, unconstrained = FALSE)
  
  # Calculate AICs for all models
  df_aicc <-
    data.frame(model = c("poly_norm",
                         "poly_ar1",
                         "linear_norm",
                         "linear_ar1"),
               aicc  = c(AICc(poly_norm),
                         AICc(poly_ar1),
                         AICc(linear_norm),
                         AICc(linear_ar1)),
               coefs = rbind(coef(poly_norm),
                             coef(poly_ar1),
                             c(coef(linear_norm), NA),
                             c(coef(linear_ar1),  NA)),
               phi = c(0, 
                       poly_phi,
                       0,
                       linear_phi),
               # Calculate overall signifiance (need to use
               # ML not REML for this)
               pval = c(anova(update(constant_norm, method = "ML"),
                              update(poly_norm, method = "ML"))$`p-value`[2],
                        anova(update(constant_ar1, method = "ML"),
                              update(poly_ar1, method = "ML"))$`p-value`[2],
                        anova(update(constant_norm, method = "ML"),
                              update(linear_norm, method = "ML"))$`p-value`[2],
                        anova(update(constant_ar1, method = "ML"),
                              update(linear_ar1, method = "ML"))$`p-value`[2]))
  
  best_lm <-
    df_aicc %>%
    dplyr::filter(aicc == min(aicc))
  if (nrow(best_lm) >1){
    best_lm <- best_lm[1,]
  }
  phi <- best_lm$phi
  
  
  
  if (best_lm$model == "poly_norm") {
    model <- poly_norm
  } else if (best_lm$model == "poly_ar1") {
    model <- poly_ar1
  } else if (best_lm$model == "linear_norm") {
    model <- linear_norm
  } else if (best_lm$model == "linear_ar1") {
    model <- linear_ar1
  }
  
  
  return(list(best_lm = best_lm, 
              model = model))
}








  set.seed(123)
  n <- 1500
  sim_results_ext <-data.frame(matrix(ncol = 8, nrow = 0))
  names(sim_results_ext) <- c("test","series.length", "n","trend", "ar", "mae", "rmse", "p")
  
  for (m in seq(250,450,50)){
    
    notrend <- rep(0,m)
    ltrendweak <- -0.262 + (0.004 * c(1:m)) 
    ltrendmed <- -0.262 + (0.051 * c(1:m)) 
    ltrendstrong <- -0.262 + (0.147 * c(1:m)) 
    print(paste("m =",m))
    
    #Trend strength
    for (k in c("notrend")){
      
      #AR strength
      for (j in c("strongAR")){
        
        true_trend <- get(k)
        
        for (i in 1:n){
          
          print(i)
          #generate simulations
          dat <- arima.sim(list(ar = get(j)), n=m, rand.gen=rnorm, sd = ARsd)
          dat[1] <- rnorm(1,mean=0,sd=sqrt((ARsd^2)/(1-get(j)^2)))
          
          #add autocorrelated error structure to trend
          dat <- get(k) + dat
          dat <- data.frame(series = dat,
                            time = 1:length(dat))
          
          #---------------------------------GLS---------------------------------#
          #Correctly specifies model when no AR error in simulated time series
          if (j == "NOAR"){
            gls_sim <- fit_lm(dat = dat, spec = TRUE, trend = trend,
                              ar = unlist(get(k)), m = x, ARsd = ARsd)
          } else {
            gls_sim <- fit_lm(dat = dat, trend = trend,
                              ar = unlist(get(k)),m = x, ARsd = ARsd)
          }
          
          #Get prediction or assign NA if broken
          if (is.na(gls_sim[1])){
            gls_mae <- NA
            gls_rmse <- NA
          } else {
            newtime <- seq(1, m, 1)
            newdata <- data.frame(time = newtime,
                                  time2 = newtime^2)
            gls_pred <- AICcmodavg::predictSE(gls_sim$model,
                                              newdata = newdata,
                                              se.fit = F)
            ##Get error
            gls_rmse <- sqrt(mean((gls_pred - true_trend)^2))
            gls_mae <- mean(abs(gls_pred - true_trend))
          }
          
          #Results DF
          gls_df <- data.frame(test = "gls",
                               series.length = m,
                               n = i,
                               trend = k,
                               ar = j,
                               mae = gls_mae,
                               rmse = gls_rmse,
                               p = gls_sim$best_lm$pval)
          
          #---------------------------------MK---------------------------------#
          mk <- MannKendall(dat$series)
          mk_p <- unlist(mk[2])
          
          mk_df <- data.frame(test = "mk",
                              series.length = m,
                              n = i,
                              trend = k,
                              ar = j,
                              mae = NA,
                              rmse = NA,
                              p = mk_p)
          
          #---------------------------------MK-TFPW---------------------------------#
          pw <- zyp.trend.vector(dat$series,method='yuepilon')
          
          pw_pred <- pw[[11]] + 1:m * pw[[2]]
          pw_rmse <- sqrt(mean((pw_pred - true_trend)^2))
          pw_mae <- mean(abs(pw_pred - true_trend))
          pw_p <- pw[6]
          
          pw_df <- data.frame(test = "pw",
                              series.length = m,
                              n = i,
                              trend = k,
                              ar = j,
                              mae = pw_mae,
                              rmse = pw_rmse,
                              p = pw_p)
          
          int_df <- rbind(gls_df, mk_df, pw_df)
          assign('sim_results_ext',rbind(sim_results_ext, int_df))
          
        } 
      }
    }
  }
  
  
  
  
  
  #save(sim_results_ext, file = file.path(data.dir,paste0("sim_results_test",Sys.Date(),".Rdata")))




  pow <- sim_results_ext %>% 
    group_by(series.length, test) %>% dplyr::summarise(rej_prop = length(p[p<0.05])/n())

pow




