---
title: "A simulation study of trend detection methods for Integrated Ecosystem Assessment"
output:
  pdf_document: 
  word_document: default
  html_document:
    df_print: paged
indent: yes
geometry: margin=1in
bibliography: SOE simulations.bib
csl: ices-journal-of-marine-science.csl
documentclass: ouparticle
---


```{r setup, include=FALSE}
# rmarkdown::render("SOE_simulations_methods.Rmd", "all") # for both pdf and html

data.dir <- "data.dir/"
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	fig.pos = 'H'
)

# list of all packages required
packages <- c("stringi","boot","tinytex","Kendall","zoo","zyp",
              "trend","dplyr","AICcmodavg","nlme",
              "gtools","tidyr","stringr","ggplot2",
              "data.table","scales","RColorBrewer",
              "colorspace","mccr","cowplot","gridExtra","grid")

installLoadPackages <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE,repos='http://cran.us.r-project.org')
    sapply(pkg, require, character.only = TRUE)
}

installLoadPackages(packages)

```

```{r functions, echo = F}
#GLS-MS 
fit_lm <- function(dat, ar, m, ARsd, trend, spec = FALSE){
    dat <- dat %>% dplyr::filter(complete.cases(.))
    
    # Constant model (null model used to calculate 
    # overall p-value)
    constant_norm <-nlme::gls(series ~ 1, data = dat)
    
    #spec parameter specifies whether arima.sim incorporated AR(1) error process. When there is no 
    #AR error in the time series, we switch the GLS models to all rely on a normal error generating process.
    if (!spec){
      constant_ar1 <-
        try(nlme::gls(series ~ 1,
                      data = dat,
                      correlation = nlme::corAR1(form = ~time)))
      if (class(constant_ar1) == "try-error"){
        return(best_lm <- data.frame(model = NA,
                                     aicc  = NA,
                                     coefs..Intercept = NA,
                                     coefs.time = NA,
                                     coefs.time2 = NA,
                                     pval = NA))
      }
      
    } else {
      constant_ar1 <-
        try(nlme::gls(series ~ 1,
                      data = dat))
      if (class(constant_ar1) == "try-error"){
        return(best_lm <- data.frame(model = NA,
                                     aicc  = NA,
                                     coefs..Intercept = NA,
                                     coefs.time = NA,
                                     coefs.time2 = NA,
                                     pval = NA))
      }
    }
    # Linear model with normal error
    linear_norm <- nlme::gls(series ~ time, data = dat)
    
    # Linear model with AR1 error
    if (!spec){
      linear_ar1 <- 
        try(nlme::gls(series ~ time, 
                      data = dat,
                      correlation = nlme::corAR1(form = ~time)))
      if (class(linear_ar1) == "try-error"){
        return(best_lm <- data.frame(model = NA,
                                     aicc  = NA,
                                     coefs..Intercept = NA,
                                     coefs.time = NA,
                                     coefs.time2 = NA,
                                     pval = NA))
        }
      } else {
        linear_ar1 <- 
          try(nlme::gls(series ~ time, 
                        data = dat))
        if (class(linear_ar1) == "try-error"){
          return(best_lm <- data.frame(model = NA,
                                       aicc  = NA,
                                       coefs..Intercept = NA,
                                       coefs.time = NA,
                                       coefs.time2 = NA,
                                       pval = NA))
      }
    }
    linear_phi <- linear_ar1$modelStruct$corStruct
    linear_phi <-coef(linear_phi, unconstrained = FALSE)
    
    # Polynomial model with normal error
    dat$time2 <- dat$time^2
    poly_norm <- nlme::gls(series ~ time + time2, data = dat)

    # Polynomial model with AR1 error
    if (!spec){
      poly_ar1 <-
        try(nlme::gls(series ~ time + time2,
                      data = dat,
                      correlation = nlme::corAR1(form = ~time)))
      if (class(poly_ar1) == "try-error"){
        return(best_lm <- data.frame(model = NA,
                                     aicc  = NA,
                                     coefs..Intercept = NA,
                                     coefs.time = NA,
                                     coefs.time2 = NA,
                                     pval = NA))

      }
    }else {
      poly_ar1 <-
        try(nlme::gls(series ~ time + time2,
                      data = dat))
      if (class(poly_ar1) == "try-error"){
        return(best_lm <- data.frame(model = NA,
                                     aicc  = NA,
                                     coefs..Intercept = NA,
                                     coefs.time = NA,
                                     coefs.time2 = NA,
                                     pval = NA))

      }
    }
    poly_phi <- poly_ar1$modelStruct$corStruct
    poly_phi <- coef(poly_phi, unconstrained = FALSE)
    
    # Calculate AICs for all models
    df_aicc <-
      data.frame(model = c("poly_norm",
                           "poly_ar1",
                           "linear_norm",
                           "linear_ar1"),
                 aicc  = c(AICc(poly_norm),
                           AICc(poly_ar1),
                           AICc(linear_norm),
                           AICc(linear_ar1)),
                 coefs = rbind(coef(poly_norm),
                               coef(poly_ar1),
                               c(coef(linear_norm), NA),
                               c(coef(linear_ar1),  NA)),
                 phi = c(0, 
                         poly_phi,
                         0,
                         linear_phi),
                 # Calculate overall signifiance (need to use
                 # ML not REML for this)
                 pval = c(anova(update(constant_norm, method = "ML"),
                               update(poly_norm, method = "ML"))$`p-value`[2],
                          anova(update(constant_ar1, method = "ML"),
                                update(poly_ar1, method = "ML"))$`p-value`[2],
                          anova(update(constant_norm, method = "ML"),
                                update(linear_norm, method = "ML"))$`p-value`[2],
                          anova(update(constant_ar1, method = "ML"),
                                update(linear_ar1, method = "ML"))$`p-value`[2]))
    
    best_lm <-
      df_aicc %>%
      dplyr::filter(aicc == min(aicc))
    if (nrow(best_lm) >1){
      best_lm <- best_lm[1,]
    }
    phi <- best_lm$phi

    
    
  if (best_lm$model == "poly_norm") {
    model <- poly_norm
  } else if (best_lm$model == "poly_ar1") {
    model <- poly_ar1
  } else if (best_lm$model == "linear_norm") {
    model <- linear_norm
  } else if (best_lm$model == "linear_ar1") {
    model <- linear_ar1
  }


  return(list(best_lm = best_lm, 
              model = model))
}

#Label facets
label <- function(variable,value){
  return(facet_names[value])
}

#Confusion matrices
conf_mat <- function(df, test, filt){
  df <- df %>% filter(series.length == filt)
  
  #True positives
  true_pos_frac <- nrow(df[df$series.length != "no trend" &
                          df$p <= 0.05 &
                          df$test == test,])
  
  true_pos_tot <- nrow(df[df$trend != "no trend" &
                            df$test == test,])
  
  true_pos_freq <- true_pos_frac/true_pos_tot 
  
  #False positives
 
  false_pos_frac <- nrow(df[df$trend == "no trend" &
                        df$p <= 0.05 &
                        df$test == test,])
  
  false_pos_tot <- nrow(df[df$trend == "no trend" &
                             df$test == test,])
  
  false_pos_freq <- false_pos_frac/false_pos_tot
  
  #False negatives

  false_neg_frac <- nrow(df[df$trend != "no trend" &
                         df$p >= 0.05 &
                         df$test == test,])
  
  false_neg_tot <- nrow(df[df$trend != "no trend "&
                             df$test == test,])
  
  false_neg_freq <- false_neg_frac/false_neg_tot
  
  #true
  
  true_neg_frac <- nrow(df[df$trend == "no trend" &
                         df$p >= 0.05 &
                         df$test == test,])

  true_neg_tot <- nrow(df[df$trend == "no trend" &
                            df$test == test,])
  
  true_neg_freq <- true_neg_frac/true_neg_tot

  
  conf_mat <- data.frame(x = c("actual no","actual yes","actual no","actual yes"),
                         y = c('predicted no','predicted yes','predicted yes','predicted no'),
                         val = c(round(true_neg_freq,3), round(true_pos_freq,3),
                                 round(false_pos_freq,3),round(false_neg_freq,3)))
  
  return(conf_mat)
}

#Color palette
pal <- colorRampPalette(c("white","darkred"))
```

```{r constants for simulations, echo = F}

#set seed
set.seed(123)


run <- F #Run simulations or pull from previous results
n = 1000 #number of simulations
ARsd <- .54^.5 #standard deviation of innovations

#AR strengths
NOAR <- list()
medAR <- 0.433
strongAR <- 0.8

```

## Abstract

The identification of trends in ecosystem indicators has become a core component of ecosystem approaches to resource management, although oftentimes assumptions of statistical models are not properly accounted for in the reporting process. To explore the limitations of trend analysis of short times series, we applied three common methods of trend detection, including a generalized least squares model selection approach, the Mann-Kendall test, and Mann-Kendall test with trend-free pre-whitening to simulated time series of varying trend and autocorrelation strengths. Our results suggest that the ability to detect trends in time series is hampered by the influence of autocorrelated residuals in short series lengths. While it is known that tests designed to account for autocorrelation will approach nominal rejection rates as series lengths increase, the results of this study indicate biased rejection rates in the presence of even weak autocorrelation for series lengths often encountered in indicators developed for ecosystem-level reporting (N = 10, 20, 30). This work has broad implications for ecosystem-level reporting, where indicator time series are often limited in length, maintain a variety of error structures, and typically are assessed using a single statistical method applied uniformly across all time series. If a hypothesis testing approach for indicator trend analysis is to be implemented, we suggest first characterizing candidate series based on suitability (e.g. based on variance, autocorrelation, and series length) rather than a uniform application of tests for trend. A parametric approach to trend assessment could then be used to provide estimates of uncertainty and trend strengths from probability distributions.

\textbf{Keywords}: Ecosystem-based fisheries management, trend analysis, time series


\newpage

## Introduction

 The development and analysis of indicators plays a key strategic role in implementing the Ecosystem Approach for a host of science, management, and intergovernmental organizations [e.g. @NOAA2006; @ICES2013; @SecretariatoftheConventiononBiologicalDiversity2004; @Pices2010; @Garcia2003; @Levin2009a]. At least partially in support of this, substantial effort has been invested in assessing indicator status and trends for the purpose of ecosystem reporting, in all of its guises [e.g. @Garfield2016; @NEFSC2018a; @NEFSC2018b; @NEFSC2018c; @NEFSC2018d; @Blanchard2010; O'Brien 2017; @Butchart2010].

Ecosystem-level indicators often vary greatly with respect to the length of the series under investigation. The ultimate goal of providing integrated advice often leads analysts to truncate longer datasets; generating a consistent series length across indicators for comparison purposes [e.g. @Blanchard2010; @Shin2010; @Shannon2010; @Canales2015]. Further reinforcing this approach is the fact that managers tend to focus on short-term issues [@SecretariatoftheConventiononBiologicalDiversity2004; @Wagner2013], which ultimately necessitates the assessment of trajectories at relatively short time scales.

These issues can lead to the use of short time series for the purpose of ecosystem reporting; i.e. less than 20 data points per indicator [@Blanchard2010; @Shin2010; @Shannon2010; @Canales2015; @Mackas2001; @Nicholson2004]. Statistical trend analysis of indicator data is the gold standard for managers, stakeholders, and analysts. However, in reality trend analysis in this context can be extremely difficult. Evidence indicates that the statistical power to identify trends using short time series may be limited in general [@bence1995; @Nicholson2004; @Wagner2013]. The hydrological, climatological, and statistical  literature shows that autocorrelation in time series can falsely inflate trend detection rates when models are incorrectly specified assuming the independence of error terms [@Kulkarni1995; @woodward1997; @hamed1998; @VonStorch1999a; @Nicholls2001a; @roy2004; @Zhang2000; @Wang2001a;  @Yue2002a; @Bayazit2015]. The magnitude of assigned trends can also be inflated by the presence of autocorrelation, and both of these problems are amplified by short time series [@Kulkarni1995; @Yue2002a]. Despite this, there has been no systematic investigation for the performance of models in detecting trends across the full breadth of indicators utilized in ecosystem reporting.

In this manuscript we abstract away from issues surrounding the identification and vetting of appropriate indicators, but note that this in itself can be a challenging undertaking for which @Bundy2017 present a survey of the literature. We focus, instead, on the ability to statistically identify trends for the broad array of indicators used in marine ecosystem reporting; ranging from large-scale climatological and oceanographic drivers through the benefits derived by human society. We use Monte Carlo simulations to assess the performance of the most commonly applied statistical models under a range of time series lengths, trend strengths, and autocorrelation regimes. The simulations are parameterized using the properties of indicators currently presented in the Mid-Atlantic and New England State of the Ecosystem Reports, which are annual ecosystem status reports tailored for the U.S. Mid-Atlantic and New England Fishery Management Councils respectively [@NEFSC2018a; @NEFSC2018b].

Results indicate that correctly identifying trends is problematic using less than 30 data points, with both Type I and Type II error common. Even under the strongest signal-noise ratio (i.e. strong trends and no autocorrelation) tests perform poorly when series lengths are less than 30. The simulations highlight problems associated with standardizing approaches across indicators, and suggest that further thought is warranted on status and trend analysis in the context of ecosystem reporting.

## Methods

#### Data

Parameters used in simulations were chosen based on preliminary analyses characterizing the distribution of trend and autocorrelation strengths across 124 time series that were candidates for inclusion in the 2017 State of the Ecosystem (SOE) reports [@NEFSC2018a; @NEFSC2018b] (Fig. 1). Trends in these candidate time series were characterized by linear regression, with the mean and upper 95% confidence interval for slopes chosen for representation in simulations. The $\rho$ components of SOE time series were estimated by maximum likelihood estimation (MLE), and the distribution mean was chosen as our "medium autocorrelation" parameter for simulated series. To reasonably parameterize simulation innovation variance, we fit all residual series with an AR(1) model estimating innovation variance using MLE, and then found the mean of the resulting distribution of variances.

```{r preliminary analyses, echo = F, fig.align="center", fig.asp=0.3, fig.cap="Frequency of estimated slopes (A), autocorrelation strengths (B), and innovation variances (C) in time series considered for inclusion in the 2017 State of the Ecosystem report. The solid red lines (A-C) represent distribution means, and the dashed red line (A) shows the upper 95\\% confidence interval for estimated trend slopes. \\label{Fig1}"}
load('data.dir/SOE_data_2017.RData')

fields <- c('GOM Benthos Landings','GOM Mesoplanktivore Landings',
            'GOM Macroplanktivore Landings','GOM Macrozoo-piscivore Landings',
            'GOM Benthivore Landings','GOM Piscivore Landings',
            'GOM Benthos Revenue','GOM Mesoplanktivore Revenue',
            'GOM Macroplanktivore Revenue','GOM Macrozoo-piscivore Revenue',
            'GOM Benthivore Revenue','GOM Piscivore Revenue','GOM Benthos Fall',
            'GOM Mesoplanktivore Fall','GOM Macroplanktivore Fall',
            'GOM Macrozoo-piscivore Fall','GOM Benthivore Fall',
            'GOM Piscivore Fall','GOM Benthos Spring',
            'GOM Mesoplanktivore Spring','GOM Macroplanktivore Spring',
            'GOM Macrozoo-piscivore Spring','GOM Benthivore Spring',
            'GOM Piscivore Spring','FALL GOM ESn',
            'SPRING GOM ESn','Right whale population',
            'GOM PPD','GOM Yearly Calanus Anomaly',
            'GOM Yearly Zooplankton Biovolume','GOM Yearly small copeopods anomaly',
            'MAB Benthos Landings','MAB Mesoplanktivore Landings',
            'MAB Macroplanktivore Landings', 'MAB Macrozoo-piscivore Landings',
            'MAB Benthivore Landings','MAB Piscivore Landings',
            'MAB Benthos Revenue','MAB Mesoplanktivore Revenue',
            'MAB Macroplanktivore Revenue', 'MAB Macrozoo-piscivore Revenue',
            'MAB Benthivore Revenue','MAB Piscivore Revenue','MAB Benthos Fall',
            'MAB Mesoplanktivore Fall','MAB Macroplanktivore Fall',
            'MAB Macrozoo-piscivore Fall','MAB Benthivore Fall',
            'MAB Piscivore Fall','MAB Benthos Spring',
            'MAB Mesoplanktivore Spring','MAB Macroplanktivore Spring',
            'MAB Macrozoo-piscivore Spring','MAB Benthivore Spring',
            'MAB Piscivore Spring','FALL MAB ESn',
            'SPRING MAB ESn','Right whale population',
            'MAB PPD','MAB Yearly Calanus Anomaly',
            'MAB Yearly Zooplankton Biovolume','MAB Yearly small copeopods anomaly',
            'Sea Surface Temperature','Gulf Stream Index',
            'Surface temp GB','Bottom temp GB','Stratification (0-50m) GB core',
            'Surface Salinity GB','Bottom salinity GB',
            'Surface temp GOM','Bottom temp GOM',
            'Stratification (0-50m) GOM core',
            'Bottom salinity GOM','Gulf Stream Index',
            'New England fleet count','New England average fleet diversity',
            'New England commercial species diversity','North Atlantic Rec participation',
            'North Atlantic angler trips','Mid-Atlantic fleet count',
            'Mid-Atlantic average fleet diversity','Mid-Atlantic commercial species diversity',
            'Mid-Atlantic Rec participation','Mid-Atlantic angler trips',
            'aquaculture VA hard clams sold','aquaculture VA oysters sold',
            'aquaculture VA hard clams planted','aquaculture VA oysters planted',
            'aquaculture ME Atlantic salmon harvest weight','aquaculture ME trout harvest weight',
            'aquaculture ME blue mussels harvest weight','aquaculture ME oysters harvest weight',
            'aquaculture RI total value value','aquaculture RI oysters sold',
            'GB Benthos Landings','GB Mesoplanktivore Landings',
            'GB Macroplanktivore Landings','GB Macrozoo-piscivore Landings',
            'GB Benthivore Landings','GB Piscivore Landings',
            'GB Benthos Revenue','GB Mesoplanktivore Revenue',
            'GB Macroplanktivore Revenue','GB Macrozoo-piscivore Revenue',
            'GB Benthivore Revenue','GB Piscivore Revenue',
            'GB Piscivore Fall', 'GB Benthivore Fall',
            'GB Macrozoo-piscivore Fall','GB Macroplanktivore Fall',
            'GB Mesoplanktivore Fall','GB Benthos Fall',
            'GB Piscivore Spring', 'GB Benthivore Spring',
            'GB Macrozoo-piscivore Spring','GB Macroplanktivore Spring',
            'GB Mesoplanktivore Spring','GB Benthos Spring',
            'FALL GB ESn','SPRING GB ESn','GBK PPD',
            'GBK Yearly Calanus Anomaly','GBK Yearly Zooplankton Biovolume',
            'GBK Yearly small copeopods anomaly')


nlm <- function(field, lin = NULL, norm = NULL){
  time <- SOE.data[SOE.data$Var == field,]$Time
  end = max(time)
  time = time[1:which(time == end)]
  
  var <- SOE.data[SOE.data$Var == field,]$Value
  var <- var[1:length(time)]
  
  
  if(norm == TRUE){
    var = (var-mean(var))/sd(var)
  } else {
    var = var
  }
  
  if(lin == TRUE){
    time <- c(1:length(time))
    mod <- lm(var ~ time)
    int <- mod$coefficients[1]
    beta <- mod$coefficients[2]
  } else if (lin == FALSE){
    time <- c(1:length(time))
    time2 <- time^2
    mod <- lm(var ~ time + time2)
    int <- mod$coefficients[1]
    beta <- mod$coefficients[c(2,3)]
  }
  out <- c(int, beta)
  return(out)
}
lm_resid <- function(field, lin = NULL, norm = NULL){
  time <- SOE.data[SOE.data$Var == field,]$Time
  end = max(time)
  time = time[1:which(time == end)]
  
  var <- SOE.data[SOE.data$Var == field,]$Value
  var <- var[1:length(time)]
  
  if(norm == TRUE){
    var = (var-mean(var))/sd(var)
  } else {
    var = var
  }
  
  if(lin == TRUE){
    time <- c(1:length(time))
    mod <- lm(var ~ time)$residuals
  } else if (lin == FALSE){
    time <- c(1:length(time))
    time2 <- time^2
    mod <- lm(var ~ time + time2)$residuals
  }
  return(mod)
}



get_dat <- function(field,norm = NULL){
  time <- SOE.data[SOE.data$Var == field,]$Time
  end = max(time)
  time = time[1:which(time == end)]
  
  var <- SOE.data[SOE.data$Var == field,]$Value
  var <- var[1:length(time)]
  
  
  if(norm == TRUE){
    var = (var-mean(var))/sd(var)
  } else {
    var = var
  }
  
  out <- data.frame(var = field,
                    value = var,
                    time = time)
  
  return(out)
  
}

#residuals
lin_resid <- mapply(lm_resid,fields, lin = TRUE, norm = TRUE)

#linear coefficients
beta_lin <- mapply(nlm, fields, lin = TRUE, norm = TRUE)
lin_coefficients <- data.frame("Fields"  = fields,
                               "Intercept" = beta_lin[1,],
                               "beta1" = beta_lin[2,])

#AR
AR_coef <- NULL
arima_intercept <- NULL
sigma2 <- NULL
for (i in 1:length(lin_resid)){
  z <- arima(lin_resid[[i]], c(1,0,0))
  AR_coef[i] <- z$coef[1]
  arima_intercept[i] <- z$coef[2]
  sigma2[i] <- z$sigma2
}
arima_lin_df <- data.frame("Fields" = fields,
                           "AR1 Coef"=AR_coef,
                           "Intercept" = arima_intercept,
                           "Variance" = sigma2)
#summaries
abs_beta <- abs(beta_lin[2,])
mean_beta1_linear <- mean(abs_beta)
lower_95_beta1 <- quantile(x = abs_beta, probs = 0.05)
upper_95_beta1 <- quantile(x = abs_beta, probs = 0.95)
mean_AR_coef_lin <- mean(AR_coef)

mean_AR_var <- mean(arima_lin_df$Variance)

beta <- ggplot(data = lin_coefficients, aes(x = abs(beta1))) +
  geom_histogram(bins = 124, binwidth = 0.01,
                 fill = "lightblue", color = "black",
                 position = "dodge") +
  scale_y_continuous(expand = c(0,0),
                     limits = c(0,18)) +
  xlab(expression(alpha[1])) +
  ylab("") +
  geom_vline(aes(xintercept = mean_beta1_linear), col = "indianred", size = 1) +
  geom_vline(aes(xintercept = upper_95_beta1), col = "indianred", size = 1, linetype = "dashed") +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10)) +
  annotate("text", x = 0, y = 17, label = "A")

ar <- ggplot(data = arima_lin_df, aes(x = abs(AR1.Coef))) +
  geom_histogram(bins = 124, binwidth = 0.05,
                 fill = "lightblue", color = "black",
                 position = "dodge") +
  scale_y_continuous(expand = c(0,0),
                     limits = c(0,18)) +
  xlab(expression(rho)) +
  ylab("") +
  geom_vline(aes(xintercept = mean_AR_coef_lin), col = "indianred", size = 1) +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10))  +
  annotate("text", x = 0, y = 17, label = "B")


iv <- ggplot(data = arima_lin_df, aes(x = Variance)) +
  geom_histogram(bins = 124, binwidth = 0.05,
                 fill = "lightblue", color = "black",
                 position = "dodge") +
  scale_y_continuous(expand = c(0,0),
                     limits = c(0,18)) +
  xlab("Innovation variance") +
  ylab("") +
  geom_vline(aes(xintercept = mean_AR_var), col = "indianred", size = 1) +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10)) +
  annotate("text", x = 0, y = 17, label = "C")

grid.arrange(arrangeGrob(beta, 
                         ar,
                         iv, 
                         nrow = 1,
                         left = textGrob("Frequency", rot = 90, vjust = 1)), nrow=1)

```

#### Simulations

Simulated time series were generated through the addition of $AR(1)$ autoregressive processes to first-order linear models:

\begin{equation}
\begin{split}
Y_{t} = \alpha_{0} + \alpha_{1}X_{t} + \varepsilon_{t} \\
\varepsilon_{t} = \rho\varepsilon_{t-1} + \omega_{t} \\
\omega_{t} \sim N(0, \sigma^{2})
\end{split}
 \label{eqn:1}
\end{equation}

where $Y_{t}$ is the simulated series at time $t$, $\alpha_{1}$ is the slope component, and $\varepsilon_{t}$ is the AR1 error process; the strength of which is given by $\rho$, with the error component $\omega_{t}$ assumed to be derived from Gaussian white noise. Through the preliminary analysis detailed above, the levels of $\alpha_{1}$ were 0.026, 0.051, and 0.147, which we combined with three levels of $\rho$: 0, 0.43, and 0.8. For each trend strength, autocorrelation strength, and time series length, 1000 simulations were performed. To test the null hypothesis of no trend in simulated time series, we used a generalized least squares (GLS) model selection process, Mann Kendall test, and Mann Kendall test with trend-free pre-whitening. 

We focused our analyses on rejection rates of the null hypothesis of no trend, as this methodology is a common framework for assessing the flexibility of trend models to deviations from assumptions [e.g. @Yue2002a; @Yue2002b]. Further, null hypothesis testing is often applied in ecosystem indicator reporting for assessing trend [e.g. @NEFSC2018a; @NEFSC2018b]. We chose to extend this analysis of rejection rates for the scenario of no trend and strong autocorrelation to larger sample sizes (N = 50-650) to highlight the shortcoming of small sample sizes when strong autocorrelation is present. Our final analysis compared the efficacy of the non-parametric Sen's slope to the GLS estimator for assigning linear trend to data where trend was found to be significant (P < 0.05). 

#### Generalized least squares

A GLS model selection procedure was implemented to test for trend in simulated series. Two first order linear and two quadratic GLS models were fit to each simulated time series and best models were chosen using AIC corrected for small sample size (AICc). Specifically, the models were 1) linear trend with uncorrelated residuals, 2) linear trend with correlated residuals, 3) quadratic trend with uncorrelated residuals, and 4) quadratic trend with correlated residuals. Component GLS models were derived from


\begin{equation}
\begin{split}
Y_{t} = \alpha_{0} + \alpha_{1}X_{t} + \alpha_{2}X_{t}^{2} + \varepsilon_{t} \\
\varepsilon_{t} = \rho\varepsilon_{t-1} + \omega_{t} \\
\omega_{t} \sim N(0, \sigma^{2}).
\end{split}
 \label{eqn:2}
\end{equation}


The above model follows the same notation as our simulated series. Setting $\alpha_{2} = 0$ yielded linear trend models, and $\rho = 0$ gave models with uncorrelated residuals. 

#### Mann Kendall test

Further tests for trend in simulated time series were performed using the Mann-Kendall test (MK) [@mann1945; @kendall1955] and the more robust Mann-Kendall test with trend-free pre-whitening (MK-TFPW)[@Yue2002b]. The MK test is a nonparametric test for trend that assumes sample data are independent and identically distributed. Serial correlation within sample data has been found to lead to inflated rejection rates of the null hypothesis of no trend if no correction steps are applied to the MK test [@Kulkarni1995]. Residual pre-whitening is a common correction to address autocorrelation within MK tests, although pre-whitening is known to reduce the magnitude of existing trend [@Yue2002a]. The MK with trend-free pre-whitening is a step-wise procedure developed by @Yue2002b to address issues introduced by pre-whitening, and is further detailed below. Under both MK and MK-TFPW frameworks, Kendall's tau statistic is given by:



\begin{equation}
\begin{split}
S = \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\textrm{sgn}(Y_{j} - Y_{i}), \\
\end{split}
 \label{eqn:3}
\end{equation}

where $Y$ is the response vector, $n$ is the length of the series, and

\begin{equation}
\begin{split}
\textrm{sgn}(x)=\begin{Bmatrix}
1 & \textrm{if}\:x>0\\ 
0 & \textrm{if}\:x=0\\ 
-1 & \textrm{if}\:x<0
\end{Bmatrix}. \\
\end{split}
 \label{eqn:4}
\end{equation}


When there are no ties in the data, the variance of $S$ is given by 

\begin{equation}
\begin{split}
V(S) = \frac{n(n-1)(2n+5)}{18}, \\
\end{split}
 \label{eqn:5}
\end{equation}

and the distribution of $S$ when $n \geq 8$ is approximately normal and symmetric about a mean of 0 and variance, V(S). The standardized test statistic, 



\begin{equation}
\begin{split}
\textrm{Z}=\begin{Bmatrix}
\frac{S-1}{\sqrt{V(S)}} & S>0\\ 
0 & S=0\\ 
\frac{S+1}{\sqrt{V(S)}} & S<0\\ 
\end{Bmatrix}, 
\end{split}
 \label{eqn:6}
\end{equation}

is normally distributed with mean of zero and variance of one [@Wang2001a]. The null hypothesis of no trend is rejected at significance level $\alpha$ if the probability $1-\Phi(|Z|) < \alpha$, where $\Phi(x)$ is the standard normal cumulative distribution funciton.

#### Mann-Kendall trend-free pre-whitening
The Mann Kendall trend-free pre-whitening procedure as developed by @Yue2002a is composed of four steps:


\begin{enumerate}
\item \textit{Removal of trend} -  The Theil-Sen estimator (Sen, 1968; Theil, 1992) is used to estimate the slope of trend $b$, which is removed from sample data if different from zero. $b$ is given by


\begin{equation}
\begin{split}
b = \mathrm{Median}\left (\frac{y_{j} - y_{i}}{j - l}\right)\forall l < j .
\end{split}
 \label{eqn:8}
\end{equation}

Trend $b$ is removed from the series by

\begin{equation}
\begin{split}
y_{t}^{'} = y_{t} - bt,
\end{split}
 \label{eqn:9}
\end{equation}

where $y_{t}$ is the original series at time step $t$.
\item \textit{Trend-free pre-whitening} - A pre-whitening step is applied to the detrended series to remove the $AR(1)$ component. First, the lag-$1$ autocorrelation coefficient $\rho_{1}$ is found using 

\begin{equation}
\begin{split}
\rho_{k} = \frac{  \frac{1}{n-k} \sum_{t=1}^{n-k}[y_{t} - E(y_{t})][y_{t+k} - E(y_{t})]}  {\frac{1}{n}\sum_{t=1}^{n}[y_{t} - E(y_{t})]^2},
\end{split}
 \label{eqn:10}
\end{equation}

where $E(y_{t})$ is the mean of the series and $\rho_{k}$ is the lag-$k$ autocorrelation coefficient. Serial correlation is then removed from the detrended series $y_{t}^{'}$ by 

\begin{equation}
\begin{split}
Y_{t}^{'} = y_{t}^{'} - \rho_{1}y_{t}^{'}.
\end{split}
 \label{eqn:11}
\end{equation}

\item \textit{Blending trend and residual series} - Trend $b$ is added to the independent residual series $Y_{t}^{'}$ by 

\begin{equation}
\begin{split}
Y_{t} = Y_{t}^{'} + bt.
\end{split}
 \label{eqn:12}
\end{equation}

\item \textit{MK test} - Trend is assessed through the application of the Mann Kendall test as discussed above.

\end{enumerate}

## Results

```{r assessing model power, echo = F}
#Initialize null data.frame

sim_results <-data.frame(matrix(ncol = 10, nrow = 0))
names(sim_results) <- c("test","series.length", "n","trend", "ar", "mae", "rmse", "p","mean_pred","mean_true")

if (run){

#Specify time series length
for (m in c(10,20,30)){
  
  notrend <- rep(0,m)
  ltrendweak <- -0.262 + (0.0255 * c(1:m)) 
  ltrendmed <- -0.262 + (0.051 * c(1:m)) 
  ltrendstrong <- -0.262 + (0.147 * c(1:m)) 
  print(paste("m =",m))
  
  #Trend strength
  for (k in c("notrend","ltrendweak","ltrendmed","ltrendstrong")){
    
    #AR strength
    for (j in c("strongAR","medAR","NOAR")){
      
      true_trend <- get(k)
      
      for (i in 1:n){
        
        print(i)
        #generate simulations
        dat <- arima.sim(list(ar = get(j)), n=m, rand.gen=rnorm, sd = ARsd)
        if (j != "NOAR"){
          dat[1] <- rnorm(1,mean=0,sd=sqrt((ARsd^2)/(1-get(j)^2)))
        }
        
        #add autocorrelated error structure to trend
        dat <- get(k) + dat
        dat <- data.frame(series = dat,
                          time = 1:length(dat))
        
        #---------------------------------GLS---------------------------------#
        #Correctly specifies model when no AR error in simulated time series
        if (j == "NOAR"){
          gls_sim <- fit_lm(dat = dat, spec = TRUE, trend = trend,
                            ar = unlist(get(k)), m = x, ARsd = ARsd)
        } else {
          gls_sim <- fit_lm(dat = dat, trend = trend,
                            ar = unlist(get(k)),m = x, ARsd = ARsd)
        }
        
        #Get prediction or assign NA if broken
        if (is.na(gls_sim[1])){
          gls_mae <- NA
          gls_rmse <- NA
          pval <- NA
          slope_pred <- NA
          slope_true <- NA
          
        } else {
          newtime <- seq(1, m, 1)
          newdata <- data.frame(time = newtime,
                                time2 = newtime^2)
          gls_pred <- AICcmodavg::predictSE(gls_sim$model,
                                            newdata = newdata,
                                            se.fit = F)
          slope_pred <- gls_pred[2] - gls_pred[1]
          
          if (slope_pred != gls_pred[3] - gls_pred[2]){
            slope_pred <- NA
          }
          
          ##Get error
          gls_rmse <- sqrt(mean((gls_pred - true_trend)^2))
          gls_mae <- mean(abs(gls_pred - true_trend))
          pval <- gls_sim$best_lm$pval
        }
        
        
        if (k == "ltrendweak"){
          slope_true <- 0.0255
        } else if (k == "notrend"){
          slope_true <- 0
        } else if (k == "ltrendmed"){
          slope_true <- 0.051
        } else if (k == "ltrendstrong"){
          slope_true <- 0.147
        }
        
        #Results DF
        gls_df <- data.frame(test = "gls",
                             series.length = m,
                             n = i,
                             trend = k,
                             ar = j,
                             mae = gls_mae,
                             rmse = gls_rmse,
                             p = pval,
                             slope_pred = slope_pred,
                             slope_true = slope_true)

        #---------------------------------MK---------------------------------#
        mk <- MannKendall(dat$series)
        mk_p <- unlist(mk[2])
        
        mk_df <- data.frame(test = "mk",
                             series.length = m,
                             n = i,
                             trend = k,
                             ar = j,
                             mae = NA,
                             rmse = NA,
                             p = mk_p,
                             slope_pred = NA,
                             slope_true = NA)
        
        #---------------------------------MK-TFPW---------------------------------#
        pw <- zyp.trend.vector(dat$series,method='yuepilon')
        
        pw_pred <- pw[[11]] + 1:m * pw[[2]]
        pw_rmse <- sqrt(mean((pw_pred - true_trend)^2))
        pw_mae <- mean(abs(pw_pred - true_trend))
        pw_p <- pw[6]
        slope_pred <- pw[[2]]
        
        pw_df <- data.frame(test = "pw",
                            series.length = m,
                            n = i,
                            trend = k,
                            ar = j,
                            mae = pw_mae,
                            rmse = pw_rmse,
                            p = pw_p,
                            slope_pred = slope_pred,
                            slope_true = slope_true)
        
        int_df <- rbind(gls_df, mk_df, pw_df)
        assign('sim_results',rbind(sim_results, int_df))
        
    } 
   }
  }
}
  save(sim_results, file = file.path(data.dir,paste0("sim_results",Sys.Date(),".Rdata")))
}
  

```

```{r simulation results processing, echo = F}

if (!run){load(file.path(data.dir,paste0("sim_results2018-08-29.Rdata")))}
if (!run){load(file.path(data.dir,paste0("sim_results_extended2018-09-24.Rdata")))}

#set factor levels for plotting
sim_results$trend <- sim_results %>% pull(trend) %>%
                    plyr::mapvalues(., from = c("notrend","ltrendweak","ltrendmed","ltrendstrong"),
                      to = c("no trend","weak trend","medium trend","strong trend")) %>%
                      as.factor()

sim_results$ar <- sim_results %>% pull(ar) %>%
  plyr::mapvalues(., from = c("NOAR","medAR","strongAR"),
                  to = c("no AR","medium AR","strong AR")) %>%
  as.factor()

sim_results$trend = factor(sim_results$trend, levels=c('strong trend','medium trend','weak trend','no trend'))
sim_results$ar = factor(sim_results$ar, levels=c('no AR','medium AR','strong AR'))
sim_results$series.length = factor(sim_results$series.length, levels=c(10,20,30))

#aggregate p values for plotting
p_agg <- sim_results %>% group_by(series.length, trend, ar, test) %>%
  dplyr::summarise(prop = length(p[p < 0.05])/n())

#some values for text
gls <- p_agg %>% filter(ar == "no AR", test == "gls")
pw <- p_agg %>% filter(ar == "no AR", test == "pw")

perc_change1 <- abs(mean(pw$prop) - mean(gls$prop))/mean(gls$prop) * 100
nom_p<- p_agg %>% filter(trend == "no trend", ar == "no AR", series.length == 10)
strAR_noTR <- p_agg %>% filter(trend  == "no trend", ar == "strong AR", series.length == 30)

perc_change_mk <- round(abs(strAR_noTR[strAR_noTR$test == "mk",]$prop - strAR_noTR[strAR_noTR$test == "gls",]$prop)/
                        (strAR_noTR[strAR_noTR$test == "mk",]$prop) * 100,0)
perc_change_pw <- round(abs(strAR_noTR[strAR_noTR$test == "pw",]$prop - strAR_noTR[strAR_noTR$test == "gls",]$prop)/
                        (strAR_noTR[strAR_noTR$test == "pw",]$prop) * 100,0)

#sample size effect
ss1 <- p_agg %>% filter(trend  == "no trend", ar == "strong AR", series.length == 10)
ss2 <- p_agg %>% filter(trend  == "no trend", ar == "strong AR", series.length == 30)

pw1 <- ss1[ss1$test == "pw",]$prop
pw2 <- ss2[ss2$test == "pw",]$prop

pw_ss <- round((pw1 - pw2)/pw1, 2)*100

gls1 <- ss1[ss1$test == "gls",]$prop
gls2 <- ss2[ss2$test == "gls",]$prop

gls_ss <- round((gls1 - gls2)/gls1, 2)*100

```

```{r power subset, echo = F}
if (run){
set.seed(100)
n <- 1500
sim_results_ext <-data.frame(matrix(ncol = 8, nrow = 0))
names(sim_results_ext) <- c("test","series.length", "n","trend", "ar", "mae", "rmse", "p")

for (m in seq(50,650,50)){
  
  notrend <- rep(0,m)
  ltrendweak <- -0.262 + (0.004 * c(1:m)) 
  ltrendmed <- -0.262 + (0.051 * c(1:m)) 
  ltrendstrong <- -0.262 + (0.147 * c(1:m)) 
  print(paste("m =",m))
  
  #Trend strength
  for (k in c("notrend")){
    
    #AR strength
    for (j in c("strongAR")){
      
      true_trend <- get(k)
      
      for (i in 1:n){
        
        print(i)
        #generate simulations
        dat <- arima.sim(list(ar = get(j)), n=m, rand.gen=rnorm, sd = ARsd)
        dat[1] <- rnorm(1,mean=0,sd=sqrt((ARsd^2)/(1-get(j)^2)))
        
        #add autocorrelated error structure to trend
        dat <- get(k) + dat
        dat <- data.frame(series = dat,
                          time = 1:length(dat))
        
        #---------------------------------GLS---------------------------------#
        #Correctly specifies model when no AR error in simulated time series
        if (j == "NOAR"){
          gls_sim <- fit_lm(dat = dat, spec = TRUE, trend = trend,
                            ar = unlist(get(k)), m = x, ARsd = ARsd)
        } else {
          gls_sim <- fit_lm(dat = dat, trend = trend,
                            ar = unlist(get(k)),m = x, ARsd = ARsd)
        }
        
        #Get prediction or assign NA if broken
        if (is.na(gls_sim[1])){
          gls_mae <- NA
          gls_rmse <- NA
        } else {
          newtime <- seq(1, m, 1)
          newdata <- data.frame(time = newtime,
                                time2 = newtime^2)
          gls_pred <- AICcmodavg::predictSE(gls_sim$model,
                                            newdata = newdata,
                                            se.fit = F)
          ##Get error
          gls_rmse <- sqrt(mean((gls_pred - true_trend)^2))
          gls_mae <- mean(abs(gls_pred - true_trend))
        }
        
        #Results DF
        gls_df <- data.frame(test = "gls",
                             series.length = m,
                             n = i,
                             trend = k,
                             ar = j,
                             mae = gls_mae,
                             rmse = gls_rmse,
                             p = gls_sim$best_lm$pval)

        #---------------------------------MK---------------------------------#
        mk <- MannKendall(dat$series)
        mk_p <- unlist(mk[2])
        
        mk_df <- data.frame(test = "mk",
                             series.length = m,
                             n = i,
                             trend = k,
                             ar = j,
                             mae = NA,
                             rmse = NA,
                             p = mk_p)
        
        #---------------------------------MK-TFPW---------------------------------#
        pw <- zyp.trend.vector(dat$series,method='yuepilon')
        
        pw_pred <- pw[[11]] + 1:m * pw[[2]]
        pw_rmse <- sqrt(mean((pw_pred - true_trend)^2))
        pw_mae <- mean(abs(pw_pred - true_trend))
        pw_p <- pw[6]
        
        pw_df <- data.frame(test = "pw",
                            series.length = m,
                            n = i,
                            trend = k,
                            ar = j,
                            mae = pw_mae,
                            rmse = pw_rmse,
                            p = pw_p)
        
        int_df <- rbind(gls_df, mk_df, pw_df)
        assign('sim_results_ext',rbind(sim_results_ext, int_df))
        
    } 
   }
  }
}
  save(sim_results_ext, file = file.path(data.dir,paste0("sim_results_extended",Sys.Date(),".Rdata")))
}
```


Throughout this study we adopt an alpha value of 0.05 to assess significance of statistical results. Overall, no method performed consistently well in all scenarios of simulated trend strength, time series length, and autocorrelation strength. As has been documented elsewhere (Yue and Wang 2002; Yue et al. 2002), we find time series length has a large effect on the power of each test (Figure \ref{Fig2}), and performance was generally best across autocorrelation and trend scenarios when N = 30. With no autocorrelation and trend present, trends were only detected with > 90% accuracy when trend was strong ($\alpha_{1} = 0.147$). Even with a strong trend and no autocorrelation, no test detected a trend in greater than 50% of the series when N = 10. Again under no autocorrelation, the increased power associated with increasing series length diminished with reductions in trend strength across all tests. The GLS test showed the highest rejection rates compared to other tests under no autocorrelation, although this effect was minimal (percent increase of rejection rates between GLS and MK-TFPW  was ~`r round(perc_change1,0)`%). All tests returned rejection rates near the nominal significance level of 0.05 under the no trend and no autocorrelation scenarios, with the largest departures occurring when N = 10 (MK-TFPW~sig~ = `r round(nom_p[nom_p$test == "pw",]$prop,3)`, MK~sig~ = `r round(nom_p[nom_p$test == "mk",]$prop,3)`, GLS~sig~ = `r round(nom_p[nom_p$test == "gls",]$prop,3)`).
  
```{r power analysis figure, echo = F, fig.align='center',fig.cap="Barplots showing the propotion of significant trends (\\textit{P}<0.05) to number of total simulations. Subplots are representative of different autocorrelation ($\\rho = 0, .43, .8$) and trend scenarios ($\\alpha_{1} = 0.026, .051$), with time series length increasing along the x axis. Colored bars show results from different tests for trend. \\label{Fig2}"}

levels(p_agg$test) <- c("GLS","Mann-Kendall","MK-TFPW")
names(p_agg)[4] <- "Method"
ggplot(p_agg, aes(color = Method, y = prop, 
                  x = series.length)) +
  geom_bar(aes(fill = Method), stat = "identity",  position="dodge2",
            size = 0.5) +
  facet_grid(trend ~ ar, labeller = labeller(tbl)) +
  ylab("Proportion significant") +
  xlab("Series length") +
  scale_color_brewer(palette = "Paired") +
  scale_fill_brewer(palette = "Paired") +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10))

```

  Autocorrelation is known the reduce the power of the MK test by increasing the variance of the \textit{S} statistic [@VonStorch1999a; @Yue2002a], and our work also shows that under no simulated trend, introducing autocorrelation will lead to inflated rejection rates in the MK test. The bottom row of Figure \ref{Fig2} shows that under no trend and medium to strong autocorrelation ($\rho = 0.433$ and $\rho = 0.8$), the rejection rate of the Mann Kendall test increases with series length. All other tests showed decreases in rejection rates.

  The GLS procedure performed the best under the no trend and strong autocorrelation scenario: when N = 30, the rejection rate for the GLS was `r strAR_noTR[strAR_noTR$test == "gls",]$prop`; `r perc_change_pw`% and `r perc_change_mk`% lower than the MK-TFPW and MK tests respectively. The performance of the GLS test was also more strongly affected by sample size than the MK-TFPW test. When there was strong autocorrelation and no trend, rejection rates of the MK-TFPW test decreased only `r pw_ss`% between N = 10 and N = 30. Under the same conditions and GLS approach, rejection rates decreased by `r gls_ss`%. However, the GLS approach also performed the worst under no trend and strong autocorrelation when N = 10. This shows that while there was improvement between both tests as series lengths increased, neither test was effective in accounting for biases of autocorrelation when $N \leq 30$.

Extending this no trend and strong autocorrelation scenario out to longer series lengths shows that the GLS test reaches nominal rejection rates of 0.05 only when $N \geq 500$ (Figure \ref{Fig3}). The MK-TFPW approach performed poorly in this analysis, and did not converge to nominal rejection rates for $N < 500$, although this work did not seek to identify a precise value of N where the MK-TFPW approach reached nominal levels. As expected, the MK test performed poorly in this scenario, and saw no reduction in rejection rates as N increased. 

```{r power subset figure, fig.align="center", fig.asp=0.45, eval = T, echo = F, fig.show = "h", fig.cap= "Barplot showing the ratio of number of rejections (\\textit{P}<0.05) to number of total simulations, when simulations were created under the parameters of no trend $(\\alpha_{1} = 0)$, strong autocorrelation $(\\rho = 0.8)$, and series lengths between \\textit{N} = 50 to $N = 500$. The dashed red line shows the nominal rejection rate of 0.05.\\label{Fig3}"}

pow <- sim_results_ext %>% group_by(series.length, test) %>% dplyr::summarise(rej_prop = length(p[p<0.05])/n())

pow$series.length <- as.factor(pow$series.length)
levels(pow$test) <- c("GLS","Mann-Kendall","MK-TFPW")
names(pow)[2] <- "Method"

ggplot(pow, aes(x = series.length, y = rej_prop, group = Method,fill = Method)) +
  geom_bar(stat = "identity",position="dodge") +
  geom_hline(yintercept=0.05, linetype="dashed", 
             color = "red", size=1) +
  ylab("Proportion significant") +
  xlab("Series length") +
  scale_fill_brewer(palette = "Paired") +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10))
```

Shown in Figure \ref{Fig2} under strong autocorrelation ($\rho = 0.8$) and strong trend ($\alpha_{1} = 0.147$), the relationship between time series length and rejection rate was positive, highlighting the importance of the trend signal strength on test results. Under these parameters, the MK-TFPW test performed slightly better than the GLS approach, although both tests were only able to detect trend in >50% of simulations when trend was strong and N = 20 or N = 30. When $\alpha_{1} < 0.0147$ and autocorrelation was strong, neither the GLS nor MK-TFPW tests were able to detect trend in >50% of simulations regardless of series length. Interestingly, as series lengths increased when trend was weak (i.e. $\alpha_{1} = 0.026$) and $\rho = 0.8$, rejection rates tended to decrease for GLS and MK-TFPW tests. The relative success of each test when N = 30 can be seen in Figure \ref{Fig4}, which shows that the GLS approach was most effective in avoiding false positives, but performed similarly to the MK-TFPW test in terms of false negatives.      
  
```{r confusion matrices, echo = F, fig.align='center', out.extra='trim={0cm 5cm 0cm 0cm},clip', fig.cap= 'Confusion matrices showing aggregate results from testing for trend across all combinations autocorrelation and trend strength when N=30. Colors represent the performance of individual cells across tests, where cells shaded in red indicate a poorer outcome. For example, when N=30, the GLS procedure falsely predicted a trend when there was none in 11.1\\% of cases (white), whereas this was true in 22.1\\% of Mann-Kendall simulations (red).\\label{Fig4}' }

mk <- cbind(conf_mat(sim_results,test = "mk", filt = 30), test = rep('mk',4))
pw <- cbind(conf_mat(sim_results, test = "pw", filt = 30), test = rep('pw',4))
gls <- cbind(conf_mat(sim_results, test = "gls", filt = 30), test = rep('gls',4))
fin <- rbind(mk, pw, gls)
fin$group <- factor(paste(fin$x,fin$y))


#Make matrices for white = good and orange = bad
fin_dif <- fin %>% group_by(group) %>%
  mutate(val, best_dif = ifelse(group == "actual no predicted no"|
                                  group == "actual yes predicted yes",
                                (abs(max(val) - val)), #best_dif is for assigning colors
                                (abs(min(val) - val)))) 

#Facet titles
facet_names <- list(
  'mk'="Mann-Kendall",
  'pw'="MK-TFPW",
  'gls'="GLS"
)

#plot
ggplot(data = fin_dif, aes(x,y, fill = best_dif)) +
  facet_grid(. ~ test, labeller = label)+
  geom_tile(aes(size = 1),color = "grey", size = 1)  +
  scale_fill_gradientn(colors = pal(10))+
  geom_text(aes(x = x, y = y, label = round(val,3), size = 1),size = 4) +
  theme(legend.position = "none",
        axis.line = element_blank(),
        axis.title=element_blank(),
        axis.text.y = element_text(margin = margin(t = 0, r = -6,
                                                   b = 0, l = 0),
                                   size = 8),
        axis.text.x = element_text(margin = margin(t = -3, r = 0,
                                                   b = 150, l = 0),
                                   size = 8),
        axis.ticks.y=element_blank(),
        axis.ticks.x=element_blank(),
        plot.title = element_text(hjust = -0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())
```

We next assessed the ability of each statistical approach to estimate the true trend (Figures \ref{Fig5} and \ref{Fig6}). In the nonparametric case, we used Sen's slope (as derived in Equation 8), which is a common statistic estimated alongside the MK and MK-TFPW significance tests. Sen's slope and the GLS estimator perform similarly across all scenarios. For both methods, the spread of estimated trends increased with autocorrelation strength, although this effect was mediated by increasing series length (e.g. Fig \ref{Fig6}). Further, trends falsely assigned in the "no trend" scenarios tended to have the largest spread. As shown by the black median lines in Figure \ref{Fig5}, both GLS and Sen's slope methods consistently overestimated trend slope when it existed, although both performed well under the strong autocorrelation scenario when trend was strong and N = 30.

```{r trend slope, fig.align="center", echo = F, fig.cap="Violin plots showing probability densities of estimated trends from GLS and Sen's slope procedures under varying autocorrelation scenarios $(\\rho = 0, 0.43, 0.8)$ and simulation lengths (N = 10, 20, 30). Black lines represent the median slope estimate, and red lines the true slope. For this exercise, the GLS model selection procedure was constrained to fit only linear models of trend.\\label{Fig5}"}

load(file.path(data.dir,"sim_results2018-09-18.Rdata"))

df <- sim_results %>% filter(!is.na(slope_pred), p < 0.05) 

#set factor levels for plotting
df$trend <- df %>% pull(trend) %>%
  plyr::mapvalues(., from = c("notrend","ltrendweak","ltrendmed","ltrendstrong"),
                  to = c("no trend","weak trend","medium trend","strong trend")) %>%
  as.factor()

df$ar <- df %>% pull(ar) %>%
  plyr::mapvalues(., from = c("NOAR","medAR","strongAR"),
                  to = c("no AR","medium AR","strong AR")) %>%
  as.factor()

df$trend = factor(df$trend, levels=c('strong trend','medium trend','weak trend','no trend'))
df$ar = factor(df$ar, levels=c('no AR','medium AR','strong AR'))
df$series.length = factor(df$series.length, levels=c(10,20,30))
names(df)[1] <- "Method"
levels(df$Method) <- c("GLS","Mann-Kendall","Sen's slope")

ggplot(df, aes(factor(series.length), slope_pred)) + 
  geom_hline(aes(yintercept = slope_true), color = "red", size = 0.5) +
  geom_violin(aes(fill = Method), adjust = 0.5, scale = "width",
              draw_quantiles = 0.5, size = 0.3) +
  facet_grid(trend ~ ar) +
  ylab("Predicted slope") +
  xlab("Series length") +
  scale_fill_brewer(palette = "Paired") +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10))
```


```{r sd of trend estimates, fig.align = "center", echo = F, fig.cap = "Sample standard deviations of trend estimates derived from Sen's slope and GLS methods across autocorrelation strengths ($\\rho = 0, 0.433, 0.8$), trend strengths ($\\alpha_{1} = 0, 0.026, 0.052, 0.147$), and trend detection methods. \\label{Fig6}"}
stdev <- NULL

for (t in c("GLS","Sen's slope")){
  for (k in c(10,20,30)){
    for (j in c('no trend','weak trend','medium trend','strong trend')){
      for (i in c("no AR","medium AR","strong AR")){
        out <- sd(df[df$Method == t &df$series.length == k &
                       df$trend == j & df$ar == i, ]$slope_pred)
        
        out <- data.frame(stdev = out,
                          Autocorrelation = i,
                          `Trend strength` = j,
                          `Series length` = k,
                          `Method` = t)
        assign('stdev',rbind(stdev,out))
      }
      
    }
    
  }
  
}
names(stdev)[c(3,4)] <- c("Trend strength","Series length")

stdev <- stdev %>% mutate(Autocorrelation, Autocorrelation = plyr::mapvalues(Autocorrelation,
                                                                    from = c("no AR",
                                                                             "medium AR",
                                                                             "strong AR"),
                                                                    to = c(0, 0.433, 0.8))) %>%
  mutate(`Trend strength`, `Trend strength` = plyr::mapvalues(`Trend strength`,
                                                                    from = c("no trend",
                                                                             "weak trend",
                                                                             "medium trend",
                                                                             "strong trend"),
                                                                    to = c("No trend",
                                                                             "Weak trend",
                                                                             "Medium trend",
                                                                             "Strong trend")))



ggplot(data = stdev) + geom_line(aes(x = Autocorrelation, y = stdev,
                                     group = `Trend strength`, color = `Trend strength`),
                                 size = 2) + 
  facet_grid(`Method` ~ `Series length`)+
  ylab("Standard deviation of trend estimates") +
  xlab(expression(paste("Autocorrelation (",rho,")"))) +
  scale_color_brewer(palette = "Paired") +
  theme_bw() +
  theme(plot.title = element_blank(),
        strip.background = element_blank(),
        axis.text = element_text(size = 9),
        axis.title = element_text(size = 10),
        strip.text = element_text(size = 10))

```


## Discussion
Ecosystem reporting is vital to the development of Integrated Ecosystem Assessments (IEA), which lay out the framework for moving toward Ecosystem-Based Fishery Management (EBFM)[@Levin2009a]. The key analytical foundations to all IEA products revolve around the concept of indicator change; with managers most interested in short-term, abrupt changes to indicator status [@Wagner2013]. Here we addressed the shortcomings of assigning significant trends to indicator time series given the common problems of small sample size and autocorrelation. Our results show that statistical methods commonly used to detect trend in the presence of autocorrelated residuals may be misleading when applied to short time series.

In the Northeast US, indicators considered in the ecosystem assessment process are annual data typically ranging between 10-60 years in length. In the context of hydrological literature, the upper limit of time series lengths seen in our indicator data sets would be considered short [@Bayazit2015]. This study highlights the dangers of assigning trends to short time series even while attempting to address problems of autocorrelation. The influence of autocorrelation in short series inevitably increases Type II error rates (the failure to identify trend when it exists). This was especially true under scenarios of strong autocorrelation, which effectively masked the detection of trend unless trend was strong and N was large. Possibly even more problematic, an increase in Type I error, or the false rejection of the null hypothesis, occurred as the strength of autocorrelation increased. A departure from nominal rejection rates was seen from all tests with even moderate amounts of autocorrelation.

Our work focused on the capacity of tests to detect weak trend strengths in simulated time series. We found that under the limitations imposed by series lengths $\leq$ 30, no test was effective in detecting weak trends, even without autocorrelation (e.g. Figure \ref{Fig2}; no AR and weak trend scenario). Decreasing rejection rates with increasing series lengths for GLS and MK-TFPW tests under weak trend and strong autocorrelation further illustrate the "masking" effect of autocorrelation on trend detection. This result supports the work of others [e.g. @Wagner2013] that have found small trend changes in short time series difficult to detect regardless of autocorrelation. The role of autocorrelation in making trend can in part can be explained by the variance of the random error used in our simulations ($\sigma^{2} = 0.54$). While this may be considered large relative to the our definition of weak trend, it was selected based on the properties of real ecosystem indicators.

As shown in Figure \ref{Fig2}, there is no solution in small sample sizes; however, we do not suggest there is no value in assigning trends to time series. Instead, we advise that a "shotgun" approach to assessing trends in many indicator time series without consideration of error structure and series lengths will likely lead to both Type I and Type II error. If the binary approach of hypothesis testing is to be implemented in ecosystem indicator reporting, a more hands-on approach should be implemented to determine indicators that are well-suited for trend analysis (e.g. a long series with low variance and weak autocorrelation). Further, the results of this study showed that the GLS approach to modeling trend ameliorated error rates compared to the Mann-Kendall test with trend-free pre-whitening. The parametric approach also carries the benefits of modeling trend uncertainty and coefficients, given the assumed probability distribution.

A more intuitive and flexible approach to trend assessment would be to simply present more information with each assessed time series. Nicholls (2001) suggested that the arbitrary (i.e. "p < 0.05") null hypothesis testing framework be replaced by the presentation of confidence intervals for trend effect size. This approach has the potential to provide more contextual information to managers, but as we show above, is limited by the reality that trends (and therefore confidence intervals for effect size) are often misrepresented when series length is small and autocorrelation exists. Supplementing ecosystem reporting documents with methodological summaries could be useful to highlight these limitations and provide realistic expectations for managers [@Wagner2013]. 

A different approach to trend assessment departs from null hypothesis testing altogether in favor of a Bayesian framework. Wagner et al. (2013) suggests Dynamic Linear Models (DLMs) for indicators of small sample size. DLMs allow for model coefficients (e.g. slope) to change with time while providing probabilities of rate changes. This approach introduces greater complexity into the common "up or down" model subscribed to by current ecosystem status reports, and could therefore provide greater insight to managers. In an example of Bayesian regression, Wade (2000) showed how a series with larger variance but a biologically significant trend would be considered non-significant by a frequentist approach, but properly assessed by Bayesian methods. This framework could be adopted by analysts to answer specific questions that resource managers are interested in addressing; e.g. what is the probability that indicator X declined by Y% between this year and last? While Bayesian methods cannot side-step the reality of small sample sizes, their use provides managers with a probabilistic framework for decision-making that is lacking in the frequentist approach [@wade2000; @Wagner2013]. 

Deriving trends from disparate ecosystem indicators is challenging in part due to the goal of applying a single statistical approach to time series with a wide range of series lengths and error structures. The complexity of the chosen method must be balanced with its applicability to a wide range of indicators and the interpretability of its results. Our work shows that blindly implementing this approach will likely result in assigning spurious trends or missing important patterns. However, programmatic consideration of candidate series for trend analysis would likely ameliorate some instance of error. Implementation of a parametric test for trend (e.g. the GLS procedure in our study) then has the benefit of providing estimates of uncertainty and trend based on a probability distribution. A subtler approach for trend analyses in ecosystem reporting would provide better outcomes for economic, ecological, and social systems in the context of EBFM decision-making.

<!--
Although we focused solely on trend detection in indicator time series, our results imply that the limitations inherent within short time series be taken into account during the indicator selection stage. 
--> 
 



```{r decile coverage simulations, echo = F, eval = F}

#placeholders for results
gls.ts.NOAR.notrend <- NULL
gls.ts.NOAR.ltrendweak <- NULL
gls.ts.NOAR.ltrendmed <- NULL
gls.ts.NOAR.ltrendstrong <- NULL

gls.ts.medAR.notrend <- NULL
gls.ts.medAR.ltrendweak <- NULL
gls.ts.medAR.ltrendmed <- NULL
gls.ts.medAR.ltrendstrong <- NULL

gls.ts.strongAR.notrend <- NULL
gls.ts.strongAR.ltrendweak <- NULL
gls.ts.strongAR.ltrendmed <- NULL
gls.ts.strongAR.ltrendstrong <- NULL

sim_results_10 <- NULL
sim_results_20 <- NULL
sim_results_30 <- NULL


if (run){
  ptm <- proc.time()
  #Specify time series length
  for (m in c(10,20,30)){
  
  notrend <- rep(0,m)
  ltrendweak <- -0.262 + (0.004 * c(1:m)) 
  ltrendmed <- -0.262 + (0.051 * c(1:m)) 
  ltrendstrong <- -0.262 + (0.147 * c(1:m)) 
  print(paste("m=",m))

    #Trend strength
    for (k in c("notrend","ltrendweak","ltrendmed","ltrendstrong")){
    
    #AR strength
    for (j in c("strongAR","medAR","NOAR")){
    
      true_trend <- get(k)
      
      for (i in 1:nsims){
        
        #generate simulations
        dat <- arima.sim(list(ar = get(j)), n=m, rand.gen=rnorm, sd = ARsd)
        
        #add autocorrelated error structure to trend
        dat <- get(k) + dat
        dat <- data.frame(series = dat,
                          time = 1:length(dat))
        
        #---------------------------------GLS---------------------------------#
        gls_sim <- tryCatch({
          newtime <- seq(1, m, 1)
          newdata <- data.frame(time = newtime,
                                time2 = newtime^2)
          
          #Correctly specifies model when no AR error in simulated time series
          if (j == "NOAR"){
            gls_sim <- fit_lm(dat = dat, ar = get(j),
                              ARsd = ARsd, m = m, trend = get(k), spec = TRUE)
          } else{
            gls_sim <- fit_lm(dat = dat, ar = get(j), ARsd = ARsd, m = m, trend = get(k))
            
          }
          
        }, 
        error = function(e) {
          gls_sim <- "error"
        })
        
        
        #---------------------------------Decile coverage---------------------------------#
        if (is.na(gls_sim[1]) | gls_sim[1] == "error"){
          
          gls_pred <- data.frame(fit = rep(NA, m))
          decile_of_true <- rep(NA, m)
        } else {
          gls_pred <- AICcmodavg::predictSE(gls_sim$model,
                                            newdata = newdata,
                                            se.fit = TRUE)
          decile_of_true <- ceiling(10 * pnorm(q    = true_trend, 
                                           mean = gls_pred$fit, 
                                           sd   = gls_pred$se.fit))
        }
        
        

        
        for (g in 1:m){
          if (is.na(gls_pred$fit[1])){
            print("NA")
            assign(paste0("gls.ts.",j,".",k),rbind(get(paste0("gls.ts.",j,".",k)),NA))
          } else {
            assign(paste0("gls.ts.",j,".",k),rbind(get(paste0("gls.ts.",j,".",k)),decile_of_true[g]))
          }
          
        }
          
        
      } 
      
    }
  }
  sim_results = data.frame(gls.NOAR.ltrendweak = gls.ts.NOAR.ltrendweak,
                           gls.NOAR.ltrendmed = gls.ts.NOAR.ltrendmed,
                           gls.NOAR.ltrendstrong = gls.ts.NOAR.ltrendstrong,
                           gls.NOAR.notrend = gls.ts.NOAR.notrend,

                           gls.medAR.ltrendweak = gls.ts.medAR.ltrendweak,
                           gls.medAR.ltrendmed = gls.ts.medAR.ltrendmed,
                           gls.medAR.ltrendstrong = gls.ts.medAR.ltrendstrong,
                           gls.medAR.notrend = gls.ts.medAR.notrend,

                           gls.strongAR.ltrendweak = gls.ts.strongAR.ltrendweak,
                           gls.strongAR.ltrendmed = gls.ts.strongAR.ltrendmed,
                           gls.strongAR.ltrendstrong = gls.ts.strongAR.ltrendstrong,
                           gls.strongAR.notrend = gls.ts.strongAR.notrend)

    assign(paste0('sim_results_',m), rbind(get(paste0('sim_results_',m)),sim_results))
    #write.csv(sim_results, file = paste0("decile_coverage_results_",m,Sys.Date(),".csv"))
    
    gls.ts.NOAR.notrend <- NULL
    gls.ts.NOAR.ltrendweak <- NULL
    gls.ts.NOAR.ltrendmed <- NULL
    gls.ts.NOAR.ltrendstrong <- NULL
    
    gls.ts.medAR.notrend <- NULL
    gls.ts.medAR.ltrendweak <- NULL
    gls.ts.medAR.ltrendmed <- NULL
    gls.ts.medAR.ltrendstrong <- NULL
    
    gls.ts.strongAR.notrend <- NULL
    gls.ts.strongAR.ltrendweak <- NULL
    gls.ts.strongAR.ltrendmed <- NULL
    gls.ts.strongAR.ltrendstrong <- NULL
    print(proc.time() - ptm)
}

coverage_10 <- sim_results_10  
coverage_20 <- sim_results_20  
coverage_30 <- sim_results_30  
  
write.csv(sim_results_10, file = paste0(data.dir,"coverage_10","_",date,".csv"))
write.csv(sim_results_20, file = paste0(data.dir,"coverage_20","_",date,".csv"))
write.csv(sim_results_30, file = paste0(data.dir,"coverage_30","_",date,".csv"))
  
} else if (!run){

  coverage_10 <- read.csv(file = paste0(data.dir,"coverage_10","_",date,".csv"))
  coverage_20 <- read.csv(file = paste0(data.dir,"coverage_20","_",date,".csv"))
  coverage_30 <- read.csv(file = paste0(data.dir,"coverage_30","_",date,".csv"))
}


```

```{r decile coverage plots, echo = F, fig.align='center', eval = F}

#---------------------------Process data--------------------------#
sim_30 <- tidyr::gather(coverage_30, var, value, gls.NOAR.ltrendweak:gls.strongAR.notrend, factor_key=TRUE)
sim_30$`Series length` <- "30"
sim_20 <- tidyr::gather(coverage_20, var, value, gls.NOAR.ltrendweak:gls.strongAR.notrend, factor_key=TRUE)
sim_20$`Series length` <- "20"
sim_10 <- tidyr::gather(coverage_10, var, value, gls.NOAR.ltrendweak:gls.strongAR.notrend, factor_key=TRUE)
sim_10$`Series length` <- "10"
sims <- rbind(sim_10, sim_20, sim_30)

sim_table <- sims %>% group_by(`Series length`, var,value)  %>%
  filter(value != 0) %>%
  tally() %>%
  group_by(`Series length`) %>% mutate(n = n/(as.numeric(`Series length`)*nsims))#freq. table


#------------------Split out columns for grouping----------------#
col <- do.call(rbind.data.frame, str_split(sim_table$var, '[.]'))
names(col) <- c("Test","AR","Trend Strength")
sim_table$Test <- col$Test
sim_table$AR <- col$AR
sim_table$Trend.Strength <- col$`Trend Strength`

#Set factor levels for ordering facet_grid()
sim_table$Trend.Strength = factor(sim_table$Trend.Strength, levels=c('ltrendstrong','ltrendmed','ltrendweak','notrend'))

sim_table$AR = factor(sim_table$AR, levels=c('NOAR','medAR','strongAR'))

#------------------Make figure---------------------#

ar_names <- c(`NOAR` = "No AR (phi = 0)",
                    `medAR` = "Med. AR (phi = 0.433)",
                    `strongAR` = "Strong AR (phi = 0.8)")

trend_names <- c(`ltrendstrong`="Strong trend",
                 `ltrendweak` = "Weak trend",
                 `notrend` = "No trend",
                 `ltrendmed` = "Med. trend")
#... + facet_grid(hospital ~ ., labeller = as_labeller(hospital_names))

ggplot(sim_table, aes(color = `Series length`,x = value, y = n)) +
  geom_bar(aes(fill = `Series length`),stat = "identity", position = "dodge", color = "steelblue",
           size = 0.1) +
  ylab("Fraction of Total Observations in Decile") +
  xlab("Decile") +
  scale_x_discrete(limits = c(1:10)) +
  facet_grid(Trend.Strength ~ AR,  labeller = labeller(Trend.Strength = as_labeller(trend_names),
                                                AR = as_labeller(ar_names))) +
  theme_bw()

```

\newpage


## References